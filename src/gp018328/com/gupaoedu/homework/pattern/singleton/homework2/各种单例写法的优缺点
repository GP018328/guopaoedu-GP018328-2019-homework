1、饿汉式
特点
•	1、是线程安全的
•	2、类不是延时加载「直接是类加载的时候就初始化」
优缺点
•	1、优点：没有加锁，执行效率非常高；
•	2、缺点：在类加载的时候就会初始化，浪费内存；
             序列化和反序列化会破坏单例模式
             反射能调用构造方法

2、懒汉式线程不安全(无synchronized)
特点
•	1、线程不安全
•	2、延时初始化类，在我需要的时候「也就调用 getInstance」的时候才去初始化化
优缺点
•	1、优点：延时初始化类，省资源，不想用的时候就不会浪费内存
•	2、缺点：线程不安全，多线程操作就会有问题
             序列化和反序列化会破坏单例模式
             反射能调用构造方法

3、懒汉式线程安全(synchronized)
特点
•	1、线程安全
•	2、延时初始化类，在我需要的时候「也就调用 getInstance」的时候才去初始化化

优缺点
•	1、优点：延时初始化类，省资源，不想用的时候就不会浪费内存，并且线程安全；
•	2、缺点：虽然线程安全，但是加了锁对性能影响非常大；
             序列化和反序列化会破坏单例模式
             反射能调用构造方法

4、DCL「双重检查锁:double-checked locking」 单例
特点
•	1、线程安全；
•	2、延时初始化类，在我需要的时候「也就调用 getInstance」的时候才去初始化化；

优缺点
•	1、优点：延时初始化类，省资源，不想用的时候就不会浪费内存，并且线程安全，双重加锁，多线程仿问性能达到提升；
•	2、缺点：虽然线程安全，但是于在多线程中由于指令重排会有问题；
             序列化和反序列化会破坏单例模式
             反射能调用构造方法

5、静态内部类单例模式
特点
•	1、线程安全
•	2、延时初始化类，在我需要的时候「也就调用 getInstance」的时候才去初始化化
优缺点
•	1、优点：延时初始化类，省资源，不想用的时候就不会浪费内存,并且线程安全，还可以执行其它的静态方法
•	2、缺点： 静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去；
getInstance()方法并没有多次去new对象，
故不管多少个线程去调用getInstance()方法，取的都是同一个INSTANCE对象，而不用去重新创建。
当getInstance()方法被调用时，内部类才会外部类的运行时常量池里，把符号引用替换为直接引用，这时静态对象也真正被创建，然后再被getInstance()方法返回出去，这点同饿汉模式。
那么内部类在创建过程中又是如何保证线程安全的呢？
虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，
其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，
就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，其他线程唤醒之后不会再次进入<clinit>()方法。
同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。

6、枚举类单例
•	1、枚举类类型是 final 的「不可以被继承」
•	2、构造方法是私有的
•	3、类变量是静态的
•	4、没有延时初始化，随着类的初始化就初始化了
•	5、枚举也是线程安全的
•	6、写法简单
•	7、支持序列化和反序列化操作
•	8、反射也不能调用构造方法